#include <app.h>
#include <cfgint.h>
#include <ipmc.h>
#include <log.h>
#include <debug.h>

#include <net/tcp.h>
#include <net/ip.h>

#include <user_tcpserv.h>
#include <app/signal.h>

#include <stdio.h>

#ifndef NULL
#define NULL ((void *)0)
#endif

/* Callback handlers */
static char data_handler(const ip_addr_t to,
                         unsigned short to_port,
                         const ip_addr_t from,
                         unsigned short from_port,
                         const unsigned char *data,
                         unsigned short len,
                         unsigned char *reply,
                         unsigned *replyLen);

static char connect_handler(const ip_addr_t from,
                            unsigned short from_port);

static char disconnect_handler(const ip_addr_t from,
                               unsigned short from_port);

void
lowercase(char s[]);

void
remove_extra_spaces(char s[]);

char *
get_param(const char * s, const int pos);

int
get_signal_index(const char * sm_signal_name);

int
get_cmd_index(const char * cmd);

int
write_gpio_signal(const char * cmd, char * reply);

int
read_gpio_signal(const char * cmd, char * reply);

/* ================================================================ */

typedef struct pin_map_n {
  const char *sm_name;
  const int writable;
  const signal_t ipmc_name;
  const int initial;
} pin_map_t;

pin_map_t pin_map[] = {
  {"ipmc_zynq_en"     , 1, USER_IO_3 , 0}, 
  {"en_one_jtag_chain", 1, USER_IO_4 , 0}, 
  {"uart_addr0"       , 1, USER_IO_5 , 0}, 
  {"uart_addr1"       , 1, USER_IO_6 , 0}, 
  {"zynq_boot_mode0"  , 1, USER_IO_7 , 1}, 
  {"zynq_boot_mode1"  , 1, USER_IO_8 , 1}, 
  {"sense_rst"        , 1, USER_IO_9 , 0}, 
  {"mezz2_en"         , 1, USER_IO_10, 0}, 
  {"mezz1_en"         , 1, USER_IO_11, 0}, 
  {"m24512_we_n"      , 1, USER_IO_12, 1}, 
  {"eth_sw_pwr_good"  , 0, USER_IO_13, 0}, 
  {"eth_sw_reset_n"   , 1, USER_IO_16, 1},
  {NULL, 0, USER_IO_16, 0}
};

typedef struct cmd_map_n {
  const char * cmd;
  const int (*fnc_ptr)(const char * cmd, char * reply);
} cmd_map_t;

cmd_map_t cmd_map[] = {
  {"set_gpio", NULL}, // write_gpio_signal},
  {"get_gpio", NULL}, // read_gpio_signal},
  {NULL, NULL}
};



/* Connection slot array used to manage the client */
static user_tcpserv_users_t clients[MAX_USER_TCPSERV_CLIENT];

/* INIT_CALLBACK: called at initialisation of the IPMC */
int
INIT_CALLBACK(user_gpioserv_init)
{
    tcp_connect_server(connect_handler, disconnect_handler, data_handler, 5000);
}

/* TIMER_CALLBACK: called every 1s */

TIMER_CALLBACK(1s, user_gpioserv_timercback)
{
	unsigned i;

	unsigned char *data = (unsigned char *)"alive\n";
	unsigned len = 6;
	
	/* Scan the connection slot to send data to all of the clients */
    for(i=0; i < MAX_USER_TCPSERV_CLIENT; i++){
		user_tcpserv_users_t *client = &clients[i];
		
		/* Check if the slot is in use */
		if(client->opened){
			
			/* Send "len" bytes of "data" */
			tcp_send_packet(client->to, client->to_port, data, len);
			
		}
		
	}
}

/* 
 * Name: user_tcpserv_connect_handler
 *
 * Parameters:
 *		- from: client IP address
 *		- from_port: client tcp port
 *
 * Description: Called when a client requests a connection. The
 *              prototype of this function is defined by the TCP/IP
 *              library and cannot be changed.
 */
char connect_handler(const ip_addr_t from, unsigned short from_port){
	unsigned i;

	/* Display information in debug console */
	debug_printf("<_> user_tcpserv: " "New connection request\n");

	/* Save client information in a list */
	for(i=0; i < MAX_USER_TCPSERV_CLIENT; i++){							/* Scan the array to find an empty slot */
		user_tcpserv_users_t *client = &clients[i];
		if(client->opened == 0){							/* Check if current position is already used */
			client->to_port = from_port;					/* */
			memcpy(client->to, from, sizeof(from));			/* If not, save the client info */
			client->opened = 1;								/* */

			return 0;														/* Return successfully */
		}
	}

	/* Print a warning message when no slot is available */
	debug_printf("<W> user_tcpserv: " "No user_tcpserv connection slot available\n");
	
	/* And quit de function with error */
	return 1;
}

/* 
 * Name: user_tcpserv_disconnect_handler
 *
 * Parameters:
 *		- from: client IP address
 *		- from_port: client tcp port
 *
 * Description: Called when a client sends a disconnect request. The prototype of this function is defined by the TCP/IP library
 *              and cannot be changed.
 */
char disconnect_handler(const ip_addr_t from, unsigned short from_port){
	unsigned i;

	/* Display information in debug console */
	debug_printf("<_> user_tcpserv: " "Disconnect request received\n");

	/* Search for the client slot in the array */
	for(i=0; i < MAX_USER_TCPSERV_CLIENT; i++){
		user_tcpserv_users_t *client = &clients[i];
		
		/* Check the information */
		if(client->opened == 1 && !memcmp(from, client->to, sizeof(from)) && from_port == client->to_port){
			
			/* Remove the information and set the opened variable to 0 (slot not used) */
			client->to_port = 0;
			memset(client->to, 0, 4);
			client->opened = 0;
			
		}
	}

	/* Return successfully */
	return 0;
}

/* 
 * Name: user_tcpserv_data_handler
 *
 * Parameters:
 *		- to: server IP address (IPMC)
 *		- to_port: server tcp port (IPMC)
 *		- from: client IP address
 * 		- from_port: client tcp port
 *		- data: data received(Array)
 *		- len: Length in byte of the data array
 * 		- reply: array to push a reply
 *		- replyLen: Length of the reply in byte
 *
 * Description: Called when a client sends data. The prototype of this
 *              function is defined by the TCP/IP library and cannot
 *              be changed.
 */
char data_handler(const ip_addr_t to,
                  unsigned short to_port,
                  const ip_addr_t from,
                  unsigned short from_port,
                  const unsigned char *data,
                  unsigned short len,
                  unsigned char *reply,
                  unsigned *replyLen)
{
  
  if (len>=1) {
    // signal_t userio_sig = USER_IO_20;
    // if (data[0]=='1') signal_activate(&userio_sig);
    // if (data[0]=='0') signal_deactivate(&userio_sig);

    char cmd_line[CMD_LINE_LEN];
    strncpy(cmd_line, data, len);
    cmd_line[len] = '\0';
    
    lowercase(cmd_line);
    remove_extra_spaces(cmd_line);
    char * cmd = get_param(cmd_line, 0);
    int cmd_idx = get_cmd_index(cmd_line);

    // execute command, get reply and associated length
    *replyLen = cmd_map[cmd_idx].fnc_ptr(cmd_line, reply);

  }

  // something went wrong if the len of the answer of a command is negative.
  if (*replyLen < 0) {
    return -1;
  }
  
  /* Return the function successfully */
  return 0;
}

// convert string to lowercase
void lowercase(char s[])
{
  int c = 0;
  
  while (s[c] != '\0') {
    if (s[c] >= 'A' && s[c] <= 'Z') {
      s[c] = s[c] + 32;
    }
    c++;
  }
  return;
}


void remove_extra_spaces(char s[])
{
  char *p, *q, r*;


  // p initially should point to the beginning of the string
  p = s;

  // let's eliminate space chars in the beginning of the command.
  // finding the first valid char (non space). It stops if end of
  // string is reached.
  while (*p == ' ' && *p != '\0') {
    p++;
  }

  // if string starts with spaces, remove them by mean of shifting the
  // whole vector.
  if (p != s) {
    q = s;
    while (*p != '\0') {
      *q = *p;
      p++;
      q++;
    }
    *q = '\0';
  }

  // now that we ensured that we have valid chars in the beginning of
  // the string, it is time to remove all the duplicated spaces

  // p will remember the last valid char, starting from beginning of
  // the string
  p = s;

  // q will point to the next char, which should be assessed
  q = s+1;

  // while the end of the string is not seen, let's sweep the target
  // string eliminating duplicate spaces
  while (*p != '\0' and *q != '\0') {

    // if last valid char is a space and current char is also a space,
    // then ignore it
    if (*p == ' ' and *q == ' ') {
      q++;
    }

    // otherwise, if it is not a sequence of spaces, it is a valid
    // character; which means that we need to copy the current char
    // and move target to next position. NB: overwriting a char with
    // its own content in the case that p and q are adjacent to each
    // other is faster than checking if value should be copied.
    else {
      p++;
      *p = *q;
      q++;
    }
    
  }

  // finish string
  *(p+1) = '\0';
  
  return;
}


// this function receive a command string and returns a char array
// with the parameter in the specified position. Position 0 is the
// command itself.
char * get_param(const char * s,
                 const int pos)
{
  int cnt = 0;

  char * p = s;

  char param[20] = "";
  char * q = param;

  // look for parameter in a given position
  // starts with position 0
  while (*p != '\0' and cnt != pos) {
    if (*p = ' ') {
      cnt++;
    }
    p++;
  }

  // after parameter is identified, copy it to target array
  while (*p != '\0' and *p != ' ') {
    *q = * p;
    p++;
    q++;
  }
  *q = '\0';

  // if no relevant data was copied to the target, return NULL
  if (q == param) {
    return NULL;
  }

  // return the pointer to the content otherwise
  return q;
}


// the solution below was removed since changing place of the pointer
// that holds the payload data in the frame can cause disruptions. we
// have no access to the implementation of that part to ensure a safe
// behavior in this approach.
////
//// // limit current string to first parameter only and
//// // returns a pointer to the first char of the remaining parameters
//// char * get_imediate_param(char ** s) {
//// 
////   // p is our ancillary pointer
////   char * p = *s;
//// 
////   // q remembers the initial pointer
////   char * q = *s;
//// 
////   // let's look for a space or the end of the command
////   while (*p != ' ' and *p != '\0') {
////     p++;
////   }
//// 
////   // if space was found, truncate command and return pointer to last 
////   if (*p == ' ') {
////     *p = '\0';
////     p++;
////     *s = p;
////   }
////   
////   else if (*p == '\0') {
////     p = NULL;
////   }
////   
////   return p;
//// }


// look for signal information in the pin map table and return its
// position. -1 is returned in case no signal is found.
int
get_signal_index(const char * sm_signal_name)
{
  for (int i = 0; pin_map[i].name != NULL; i++) {
    if (strcmp(pin_map[i].name, sm_signal_name) == 0) {
      return i;
    }
  }
  return -1;
}

// look for command information in the command map table and return
// its position. -1 is returned in case no command is found.
int
get_cmd_index(const char * cmd)
{
  for (int i = 0; cmd_map[i].name != NULL; i++) {
    if (strcmp(cmd_map[i].cmd, cmd) == 0) {
      return i;
    }
  }
  return -1;
}


int
write_gpio_signal(const char * cmd,
                  char * reply)
{
  int idx = get_signal_index(sm_signal_name);
  
  if (idx >= 0) {

    signal_t userio_sig = pin_map[idx].ipmc_name;
  
    if (pin_map[idx].writable = 1) {
      if (value[0] == '1' || value[0] == 'h'){
        signal_deactivate(&userio_sig);
      }
      else if (value[0] == '1' || value[0] == 'h') {
        signal_activate(&userio_sig);
      }
    }
  }

  reply[0] = 'O';
  reply[1] = 'K';
  return 2;
}

// read pin and return a char corresponding to its value.
int
read_gptio_signal(const char * cmd,
                  char * reply)
{
  int idx = get_signal_index(sm_signal_name);

  int v;
  int reply_len;

  if (idx >= 0) {

    signal_t userio_sig = pin_map[idx].ipmc_name;

    v = signal_read(&userio_sig);

    if (v == 0) {
      reply[0] = '1';
      reply_len = 1;
    }
    else if (v == 1) {
      reply[0] = '0';
      reply_len = 1;
    }
    else{
      reply_len = -1;
    }
  }

  return reply_len;
}
